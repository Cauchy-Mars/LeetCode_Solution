### 树

- 非递归前序，中序，后序遍历二叉树：中心思想都是使用栈来保存相关信息，因为递归本质上就是利用栈完成的。
    - 前序遍历：
        - 申请一个栈s，然后将根结点压入栈中；
        - 从s中弹出一个节点，输出该节点的值，然后将其右子节点和左子节点压入栈s中（当然前提是它们不为空）；
        - 不断重复步骤2，直到栈s为空为止；
    - 中序遍历：
        - 申请一个栈s，初始化另cur=root；
        - 先把cur压入栈中，然后依次把左边界压入栈中，即不停地令cur=cur.left，直到cur为空节点为止；
        - 从栈s中弹出一个节点，输出该节点的值，然后令cur=该节点的右子节点，重复步骤2；
        - 当cur为空且s也为空时，结束；
    - 后序遍历：
        - 申请栈s1和s2；
        - 将根结点压入s1中；
        - 从s1中弹出一个节点，将该节点压入s2中，并将该节点的左子节点和右子节点压入s1中；
        - 重复步骤3，直到s1为空；
        - 此时再从s2中不断弹出值，按顺序排列即为后序遍历序列；



### 链表

- 基本操作：
    - 增加：需要两个指针，一个pre，一个cur，要记录该位置的前面一个节点；
    - 删除：需要两个指针，一个pre，一个cur，要记录该位置的前面一个节点；
    - 修改：从头开始遍历查找，不需要多余的指针；
    - 查找：从头开始遍历查找，不需要多余的指针；
- 基本题型：
    - 环形链表：如果只有一个节点，那么该节点的next就是它自己；
    - 反转链表：需要三个指针，一个pre，一个cur，还有一个tmp储存cur的next，tmp的作用是当cur的next被修改为pre后，能够保证cur原来的next节点不被丢失；
    - 判断是否有环：使用快慢指针，若两指针相遇，则有环；
    - 确定环的起始位置：使用快慢指针定位交点位置，让一个指针从头跑，一个指针从交点处跑，当二者相遇时即为环的入口位置；
    - 确定环的大小：在环的入口位置设置快慢指针，当快指针第一次与慢指针相遇时慢指针走过的步数即为环的大小（刚好串了一圈）；
- 心得：
    - 基本所有的操作都需要设置一个伪头节点，这样就不用特殊处理头节点了；



### 栈和队列

- 基本操作：
    - 增加：数组后面添加元素，更新指针；
    - 删除：只能删除头或者尾的元素，仅更新指针即可；
    - 修改：不能修改某个元素；
    - 查找：只能查找头或者尾的元素，利用相应的指针就可以；

- 基本题型：
    - 用逆波兰表达式处理表达式，分为两步：
        - 将中缀表达式转换为后缀表达式，设立一个符号栈，从左到右遍历中缀表达式，遇到数字直接输出，如果遇到符号x，且栈顶符号和x平级或比x高级，那么将栈顶符号弹出，直至栈顶符号比x低级或者栈为空，最后将符号x压进栈内；如果遍历完后栈中仍有符号，则一个一个弹出，直至栈为空；
        - 设立一个数字栈，从左到右遍历后缀表达式，遇到数字直接压栈，遇到运算符则从栈顶弹出两个数字进行运算，先弹出的是右操作数，后弹出的是左操作数，运算完之后的结果再压进数字栈。这样最终栈里只有一个数字，这就是运算结果；



### 排序

- 选择排序：不稳定排序，每次从未排序的元素中选择最小/最大的元素；
- 冒泡排序：稳定排序，每次只比较相邻的两个元素，注意如果是vector的size，一定要小心size是无符号整数型；
- 堆排序：核心是adjust算法，即将指定的根结点下沉。假设数组中有n个待排序的元素，那么最后一个父节点为第(n-2)/2个点（从0开始编号），从该点开始倒序调整每个父节点，则堆就建好了。然后把堆首和最后一个元素交换，则找到一个最小/最大值，只需要adjust一次根结点，前面的n-1个元素再次构成一个堆，以此类推；
- 归并排序：分治典型例题，不断二分，直到只有一个元素为止；
- 快速排序：选定一个轴（比如第一个元素），将比他小的节点都放在它左边，比它大的节点都放在它右边，递归即可；

### 输入输出

int getc(FILE *stream)：从stream中读下一个字符，返回成功读入的字符或者EOF；

int fgetc(FILE *stream)：从stream中读入下一个字符，返回成功读入的字符或者EOF；

int getchar(void)：从stdin中读入下一个字符，返回成功读入的字符或者EOF；

int putc(int ch, FILE *stream)：向stream中写入字符ch，返回写入的字符，失败返回EOF

int fputc(int ch, FILE *stream)：向stream中写入字符ch，返回写入的字符，失败返回EOF

int putchar(int ch)：向stdout中写入一个字符ch，返回写入的字符，失败返回EOF；

char *gets(char *str)：从stdin中读入一行字符串（遇到换行符或者EOF则终止），换行符会被舍弃，在末尾会添加一个'\0'字符作为字符串的结尾标志，成功返回写入的str，失败返回空指针NULL；

char *fgets(char *str, int count, FILE *stream)：从stream中读入最多count-1个字符的字符串，并在末尾添加一个'\0'字符作为结尾标志。如果提前遇到了换行符或者EOF，则也会终止，换行符不会被丢弃，也会作为一个字符储存起来。成功返回str，失败返回空指针NULL；

int puts(const char *str)：向stdout中输出str，str末尾的'\0'不会输出，同时会在末尾添加一个换行符，成功则返回一个非负值，失败则返回EOF；

int fputs(const char *str, FILE *stream)：向stream中写入str，str末尾的'\0'不会输出，同时不会在末尾添加换行符，成功则返回一个非负值，失败则返回EOF；





### 小诀窍

- 能确定输入格式的时候，利用scanf("%xd", )的格式，可以直接按照位数读入整数，不需要读成字符串再处理；
- memset 127是最大值，128是最小值；
- priority_queue用其他容器初始化：priority_queue\<int\> name {less\<int\>(), vector}或者priority_queue\<int\> name{vector.begin(), vector.end()}；
- STL容器中的size()返回值是无符号整数，减到负数的时候一定要小心；
- 格式控制符：%\[-\]\[0\]\[m/m.n\]\[l/h\]
    - -：表示左对齐，缺省情况为右对齐（若没有规定输出数据的宽度则为左对齐）；
    - 0：当规定输出数据的宽度时，所输出的数据实际宽度小于规定的宽度，则在左边用“0”补齐；
    - m/m.n：m规定了输出数据的宽度（位数），若数据的实际宽度大于m，则突破m的限制全部输出，反之，将数据全部输出后用空格进行左补齐；n为小数点后的位数，按照四舍五入的原则进行截取；对于字符串，n表示从左至右截取的字符个数；
    - l/h：l表示长整型数据，如%ld，%lo，%lx，%lu，以及double数据，如%lf，%le，h表示短整型数据，如%hd，%ho，%hx，%hu；
    - %d：输出有符号的十进制整数，也包括char；
    - %u：输出无符号的十进制整数，也包括char；
    - %o：输出无符号的八进制整数；
    - %x：输出无符号的十六进制整数；
    - %c：输出单个字符；
    - %s：输出字符串；
    - %f：输出小数形式的十进制浮点数，输入时小数形式和指数形式都可以识别；
    - %e：输出指数形式的十进制浮点数，输入时小数形式和指数形式都可以识别；
    - %g：输出指数形式和小数形式中较短的十进制浮点数，输入时小数形式和指数形式都可以识别；
- 有符号数右移默认算术右移，无符号数右移默认逻辑右移；

- 精度处理：
    - 单精度的eps为1e-6，双精度的eps为1e-15；
    - 判断两个浮点数是否相等应该使用fabs(a-b)<=eps，判断a大于b应该使用a>b && fabs(a-b)>eps，判断a小于b应该使用a<b && fabs(a-b)>eps；
    - 如果碰到大于等于或者小于等于，那么就需要将大于/小于和等于拼接在一起，中间用或运算连接；
- math.h头文件中有一个M_PI，此即为pi的近似值；