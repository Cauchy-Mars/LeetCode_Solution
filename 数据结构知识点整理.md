### 树

- 非递归前序，中序，后序遍历二叉树：中心思想都是使用栈来保存相关信息，因为递归本质上就是利用栈完成的。
    - 前序遍历：
        - 申请一个栈s，然后将根结点压入栈中；
        - 从s中弹出一个节点，输出该节点的值，然后将其右子节点和左子节点压入栈s中（当然前提是它们不为空）；
        - 不断重复步骤2，直到栈s为空为止；
    - 中序遍历：
        - 申请一个栈s，初始化另cur=root；
        - 先把cur压入栈中，然后依次把左边界压入栈中，即不停地令cur=cur.left，直到cur为空节点为止；
        - 从栈s中弹出一个节点，输出该节点的值，然后令cur=该节点的右子节点，重复步骤2；
        - 当cur为空且s也为空时，结束；
    - 后序遍历：
        - 申请栈s1和s2；
        - 将根结点压入s1中；
        - 从s1中弹出一个节点，将该节点压入s2中，并将该节点的左子节点和右子节点压入s1中；
        - 重复步骤3，直到s1为空；
        - 此时再从s2中不断弹出值，按顺序排列即为后序遍历序列；



### 链表

- 基本操作：
    - 增加：需要两个指针，一个pre，一个cur，要记录该位置的前面一个节点；
    - 删除：需要两个指针，一个pre，一个cur，要记录该位置的前面一个节点；
    - 修改：从头开始遍历查找，不需要多余的指针；
    - 查找：从头开始遍历查找，不需要多余的指针；
- 基本题型：
    - 环形链表：如果只有一个节点，那么该节点的next就是它自己；
    - 反转链表：需要三个指针，一个pre，一个cur，还有一个tmp储存cur的next，tmp的作用是当cur的next被修改为pre后，能够保证cur原来的next节点不被丢失；
    - 判断是否有环：使用快慢指针，若两指针相遇，则有环；
    - 确定环的起始位置：使用快慢指针定位交点位置，让一个指针从头跑，一个指针从交点处跑，当二者相遇时即为环的入口位置；
    - 确定环的大小：在环的入口位置设置快慢指针，当快指针第一次与慢指针相遇时慢指针走过的步数即为环的大小（刚好串了一圈）；
- 心得：
    - 基本所有的操作都需要设置一个伪头节点，这样就不用特殊处理头节点了；



### 栈和队列

- 基本操作：
    - 增加：数组后面添加元素，更新指针；
    - 删除：只能删除头或者尾的元素，仅更新指针即可；
    - 修改：不能修改某个元素；
    - 查找：只能查找头或者尾的元素，利用相应的指针就可以；

- 基本题型：
    - 用逆波兰表达式处理表达式，分为两步：
        - 将中缀表达式转换为后缀表达式，设立一个符号栈，从左到右遍历中缀表达式，遇到数字直接输出，如果遇到符号x，且栈顶符号和x平级或比x高级，那么将栈顶符号弹出，直至栈顶符号比x低级或者栈为空，最后将符号x压进栈内；如果遍历完后栈中仍有符号，则一个一个弹出，直至栈为空；
        - 设立一个数字栈，从左到右遍历后缀表达式，遇到数字直接压栈，遇到运算符则从栈顶弹出两个数字进行运算，先弹出的是右操作数，后弹出的是左操作数，运算完之后的结果再压进数字栈。这样最终栈里只有一个数字，这就是运算结果；
    - 中缀表达式转前缀表达式：
        - 首先构造一个运算符栈(也可放置括号)，运算符(以括号为分界点)在栈内遵循越往栈顶优先级不降低的原则进行排列。
        - 从右至左扫描[中缀表达式](https://baike.baidu.com/item/中缀表达式/2725244)，从右边第一个字符开始判断：
            - 如果当前[字符](https://baike.baidu.com/item/字符)是数字，则分析到数字串的结尾并将数字串直接输出。
            - 如果是运算符，则比较[优先级](https://baike.baidu.com/item/优先级/5643121)。如果当前运算符的优先级大于等于栈顶运算符的优先级(当栈顶是括号时，直接入栈)，则将[运算](https://baike.baidu.com/item/运算/5866856)符直接入栈；否则将栈顶运算符[出栈](https://baike.baidu.com/item/出栈)并输出，直到当前运算符的优先级大于等于栈顶运算符的优先级(当栈顶是括号时，直接入栈)，再将当前运算符入栈。
            - 如果是括号，则根据括号的方向进行处理。如果是向右的括号，则直接入栈；否则，遇向左的括号前将所有的运算符全部出栈并输出，遇右括号后将向左、向右的两括号一起出栈(并不输出)，即括号夹着的运算符全部输出；
            - 重复上述操作(2)直至扫描结束，将栈内剩余运算符全部出栈并输出，再逆缀输出字符串。[中缀表达式](https://baike.baidu.com/item/中缀表达式/2725244)也就转换为前缀表达式了。



### 排序

- 选择排序：不稳定排序，每次从未排序的元素中选择最小/最大的元素；
- 冒泡排序：稳定排序，每次只比较相邻的两个元素，注意如果是vector的size，一定要小心size是无符号整数型；
- 堆排序：核心是adjust算法，即将指定的根结点下沉。假设数组中有n个待排序的元素，那么最后一个父节点为第(n-2)/2个点（从0开始编号），从该点开始倒序调整每个父节点，则堆就建好了。然后把堆首和最后一个元素交换，则找到一个最小/最大值，只需要adjust一次根结点，前面的n-1个元素再次构成一个堆，以此类推；
- 归并排序：分治典型例题，不断二分，直到只有一个元素为止；
- 快速排序：选定一个轴（比如第一个元素），将比他小的节点都放在它左边，比它大的节点都放在它右边，递归即可；





### 图

- 基本操作



- 基本题型



- 心得：
    - 要注意题目有没有明确是否有自环，两个点之间是否有多条通路的情况，在写图算法时一定要注意到这些特例；



### 数学

- 进制转换：关键是短除法一位一位求余数，如果是非十进制之间的转换，可以考虑借助十进制作为跳板进行转换；
- 最大公约数：利用辗转相除法，即(a,b)的公约数和(b, a%b)的公约数是相同的（此处a一定大于b），当b为0的时候，a即为二者的最大公约数；
- 最小公倍数：a和b的最小公倍数为a与b的乘积除以二者的最大公约数；
- 素数筛：从小到大遍历，找到一个素数，就将它的所有倍数都标记成合数（此处可以优化，当判定i为素数时，只需要从i*i开始标记为合数即可）；
- 质因数分解：首先明确，n至多只存在一个大于sqrt(n)的质因数。第一种方法，先利用素数筛打表，然后让n分别除这些素数（一个素数可以除很多遍，直到不能整除为止），直到不能够整除为止。最终的n一定为1；第二种方法，不用找素数，令i等于2，让数n不断整除i。如果n可以整除i，那么不断更新n，直到不能整除为止。此时递增i，再重复上述过程。当n小于i的时候结束即可。此时n也应该为1。

### 测试用例

- 小规模、可以手算的数据。用于快速检验程序的正确性。要注意规模不能太小以至于过分简化问题，比如对于图论题，只有2、3个点的图就太小，一般要取5、6个点。
- 大规模，但仍有规律、可以手算的数据。也是用于检验程序的正确性。如果程序算出来的结果跟手算的不同，不要急着debug，还需要考虑一下是不是手算错了哦~
- 边界和极端情况。一方面检验程序的正确性，另一方面保证复杂度不超过限制。比如二叉树退化成一条链的情况。
- 大规模随机数据。用于保证程序不会崩溃，以及复杂度不超过限制。
    - 添加头文件time.h
    - 生成随机数种子：srand((unsigned)time(NULL));
    - 之后调用rand函数，生成[0, RAND_MAX]之间的随机数；
    - 若需要输出的区间为size，且区间起始位置为a内的随机数，则rand()%size+a；
    - 生成[0,1]浮点数，1.0*rand()/RAND_MAX；
    - 任意区间内的浮点数：1.0*rand()/RAND_MAX\*size+a；

### 输入输出

int getc(FILE *stream)：从stream中读下一个字符，返回成功读入的字符或者EOF；

int fgetc(FILE *stream)：从stream中读入下一个字符，返回成功读入的字符或者EOF；

int getchar(void)：从stdin中读入下一个字符，返回成功读入的字符或者EOF；

int putc(int ch, FILE *stream)：向stream中写入字符ch，返回写入的字符，失败返回EOF

int fputc(int ch, FILE *stream)：向stream中写入字符ch，返回写入的字符，失败返回EOF

int putchar(int ch)：向stdout中写入一个字符ch，返回写入的字符，失败返回EOF；

char *gets(char *str)：从stdin中读入一行字符串（遇到换行符或者EOF则终止），换行符会被舍弃，在末尾会添加一个'\0'字符作为字符串的结尾标志，成功返回写入的str，失败返回空指针NULL；

char *fgets(char *str, int count, FILE *stream)：从stream中读入最多count-1个字符的字符串，并在末尾添加一个'\0'字符作为结尾标志。如果提前遇到了换行符或者EOF，则也会终止，换行符不会被丢弃，也会作为一个字符储存起来。成功返回str，失败返回空指针NULL；

int puts(const char *str)：向stdout中输出str，str末尾的'\0'不会输出，同时会在末尾添加一个换行符，成功则返回一个非负值，失败则返回EOF；

int fputs(const char *str, FILE *stream)：向stream中写入str，str末尾的'\0'不会输出，同时不会在末尾添加换行符，成功则返回一个非负值，失败则返回EOF；





### 小诀窍

- 能确定输入格式的时候，利用scanf("%xd", )的格式，可以直接按照位数读入整数，不需要读成字符串再处理；
- memset 127是最大值，128是最小值；
- priority_queue用其他容器初始化：priority_queue\<int\> name {less\<int\>(), vector}或者priority_queue\<int\> name{vector.begin(), vector.end()}；
- STL容器中的size()返回值是无符号整数，减到负数的时候一定要小心；
- 格式控制符：%\[-\]\[0\]\[m/m.n\]\[l/h\]
    - -：表示左对齐，缺省情况为右对齐（若没有规定输出数据的宽度则为左对齐）；
    - 0：当规定输出数据的宽度时，所输出的数据实际宽度小于规定的宽度，则在左边用“0”补齐；
    - m/m.n：m规定了输出数据的宽度（位数），若数据的实际宽度大于m，则突破m的限制全部输出，反之，将数据全部输出后用空格进行左补齐；n为小数点后的位数，按照四舍五入的原则进行截取；对于字符串，n表示从左至右截取的字符个数；
    - l/h：l表示长整型数据，如%ld，%lo，%lx，%lu，以及double数据，如%lf，%le，h表示短整型数据，如%hd，%ho，%hx，%hu；
    - %d：输出有符号的十进制整数，也包括char；
    - %u：输出无符号的十进制整数，也包括char；
    - %o：输出无符号的八进制整数；
    - %x：输出无符号的十六进制整数；
    - %c：输出单个字符；
    - %s：输出字符串；
    - %f：输出小数形式的十进制浮点数，输入时小数形式和指数形式都可以识别；
    - %e：输出指数形式的十进制浮点数，输入时小数形式和指数形式都可以识别；
    - %g：输出指数形式和小数形式中较短的十进制浮点数，输入时小数形式和指数形式都可以识别；
- 有符号数右移默认算术右移，无符号数 右移默认逻辑右移；

- 精度处理：
    - 单精度的eps为1e-6，双精度的eps为1e-15；
    - 判断两个浮点数是否相等应该使用fabs(a-b)<=eps，判断a大于b应该使用a>b && fabs(a-b)>eps，判断a小于b应该使用a<b && fabs(a-b)>eps；
    - 如果碰到大于等于或者小于等于，那么就需要将大于/小于和等于拼接在一起，中间用或运算连接；
- math.h头文件中有一个M_PI，此即为pi的近似值；