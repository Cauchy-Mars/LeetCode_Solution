### 树

- 非递归前序，中序，后序遍历二叉树：中心思想都是使用栈来保存相关信息，因为递归本质上就是利用栈完成的。
    - 前序遍历：
        - 申请一个栈s，然后将根结点压入栈中；
        - 从s中弹出一个节点，输出该节点的值，然后将其右子节点和左子节点压入栈s中（当然前提是它们不为空）；
        - 不断重复步骤2，直到栈s为空为止；
    - 中序遍历：
        - 申请一个栈s，初始化另cur=root；
        - 先把cur压入栈中，然后依次把左边界压入栈中，即不停地令cur=cur.left，直到cur为空节点为止；
        - 从栈s中弹出一个节点，输出该节点的值，然后令cur=该节点的右子节点，重复步骤2；
        - 当cur为空且s也为空时，结束；
    - 后序遍历：
        - 申请栈s1和s2；
        - 将根结点压入s1中；
        - 从s1中弹出一个节点，将该节点压入s2中，并将该节点的左子节点和右子节点压入s1中；
        - 重复步骤3，直到s1为空；
        - 此时再从s2中不断弹出值，按顺序排列即为后序遍历序列；





### 输入输出

int getc(FILE *stream)：从stream中读下一个字符，返回成功读入的字符或者EOF；

int fgetc(FILE *stream)：从stream中读入下一个字符，返回成功读入的字符或者EOF；

int getchar(void)：从stdin中读入下一个字符，返回成功读入的字符或者EOF；

int putc(int ch, FILE *stream)：向stream中写入字符ch，返回写入的字符，失败返回EOF

int fputc(int ch, FILE *stream)：向stream中写入字符ch，返回写入的字符，失败返回EOF

int putchar(int ch)：向stdout中写入一个字符ch，返回写入的字符，失败返回EOF；

char *gets(char *str)：从stdin中读入一行字符串（遇到换行符或者EOF则终止），换行符会被舍弃，在末尾会添加一个'\0'字符作为字符串的结尾标志，成功返回写入的str，失败返回空指针NULL；

char *fgets(char *str, int count, FILE *stream)：从stream中读入最多count-1个字符的字符串，并在末尾添加一个'\0'字符作为结尾标志。如果提前遇到了换行符或者EOF，则也会终止，换行符不会被丢弃，也会作为一个字符储存起来。成功返回str，失败返回空指针NULL；

int puts(const char *str)：向stdout中输出str，str末尾的'\0'不会输出，同时会在末尾添加一个换行符，成功则返回一个非负值，失败则返回EOF；

int fputs(const char *str, FILE *stream)：向stream中写入str，str末尾的'\0'不会输出，同时不会在末尾添加换行符，成功则返回一个非负值，失败则返回EOF；





### 小诀窍

- 能确定输入格式的时候，利用scanf("%xd", )的格式，可以直接按照位数读入整数，不需要读成字符串再处理；
- memset 127是最大值，128是最小值；
- priority_queue用其他容器初始化：priority_queue\<int\> name {less\<int\>(), vector}或者priority_queue\<int\> name{vector.begin(), vector.end()}；
- STL容器中的size()返回值是无符号整数，减到负数的时候一定要小心；